# Function Expression

Ֆունկցիան JavaScript-ում «լեզվի կախարդական կառուցվածք» չէ, բայց արժեքի հատուկ տեսակ է:

Այն շարահյուսությունը, որ մինչ այս օգտագործել ենք, կոչվում է *Function Declaration* (Ֆունկցիայի Հայտարարություն):

```js
function sayHi() {
  alert( "Ողջույն" );
}
```

Կա նաև այլ շարահյուսություն, որը կոչվում է *Function Expression* (Ֆունկցիայի Արտահայտություն):

Դա մեզ թույլ է տալիս ստեղծել նոր ֆունկցիա ցանկացած արտահայտության մեջտեղում:

Օրինակ.

```js
let sayHi = function() {
  alert( "Ողջույն" );
};
```

Այստեղ մենք կարող ենք տեսնել, որ `sayHi` փոփոխականը ստանում է արժեք՝ նոր ֆունկցիա, որը ստեղծվել է այսպես՝ `function() { alert("Ողջույն"); }`:

Քանի որ ֆունկցիայի ստեղծումը տեղի է ունենում վերագրման արտահայտության համատեքստում (`=` նշանի աջ կողմում), ապա սա *Function Expression* է:

Նկատի ունեցեք, որ `function` հիմնաբառից հետո չկա անվանում: Անվան բացթողումը թույլատրելի է Ֆունկցիայի Արտահայտությունների համար:

Այստեղ մենք անմիջապես վերագրում ենք այն փոփոխականին, ուստի այս կոդի նմուշների իմաստը նույնն է. «ստեղծել ֆունկցիա և տեղադրել այն `sayHi` փոփոխականում»:

Ավելի առաջադեմ իրավիճակներում, որոնց մենք հետո կհանդիպենք, ֆունկցիան կարող է ստեղծվել և անմիջապես կանչվել կամ պլանավորվել ավելի ուշ գործարկման համար, ոչ մի տեղ չպահվել, այդպիսով մնալով անանուն:

## Ֆունկցիան արժեք է

Եկեք կրկնենք. անկախ նրանից, թե ինչպես է ստեղծվում ֆունկցիան, այն արժեք է: Վերոնշյալ երկու օրինակներն էլ պահում են ֆունկցիան `sayHi` փոփոխականում:

Մենք կարող ենք նույնիսկ տպել այդ արժեքը՝ օգտագործելով `alert`.

```js run
function sayHi() {
  alert( "Ողջույն" );
}

*!*
alert( sayHi ); // ցուցադրում է ֆունկցիայի կոդը
*/!*
```

Նկատի ունեցեք, որ վերջին տողը չի գործարկում ֆունկցիան, որովհետև `sayHi`-ից հետո չկան փակագծեր: Կան ծրագրավորման լեզուներ, որտեղ ֆունկցիայի անվան ցանկացած հիշատակում հանգեցնում է դրա գործարկմանը, բայց JavaScript-ը այդպիսին չէ։

JavaScript-ում ֆունկցիան արժեք է, այնպես որ մենք կարող ենք դրան վերաբերվել որպես արժեքի: Վերոնշյալ կոդը ցույց է տալիս իր տողային ներկայացումը, որը սկզբնական կոդը է:

Անշուշտ, ֆունկցիան հատուկ արժեք է, այն իմաստով, որ մենք կարող ենք այն կանչել որպես `sayHi()`:

Բայց դա դեռևս արժեք է: Այսպիսով, մենք կարող ենք աշխատել դրա հետ, ինչպես այլ տեսակի արժեքների հետ:

Մենք կարող ենք պատճենել ֆունկցիան մեկ այլ փոփոխականում.

```js run no-beautify
function sayHi() {     // (1) ստեղծել
  alert( "Ողջույն" );
}

let func = sayHi;      // (2) պատճենել

func(); // Ողջույն     // (3) գործարկել կրկնօրինակը (սա աշխատում է)
sayHi(); // Ողջույն    //     սա նույնպես դեռ աշխատում է (ինչու ոչ)
```

Ահա մանրամասն, թե ինչ է տեղի ունենում վերևում.

1. Ֆունկցիայի Հայտարարությունը `(1)` ստեղծում է ֆունկցիա և տեղադրում այն `sayHi` փոփոխականում:
2. Տող `(2)`-ը պատճենում է այն `func` փոփոխականում: Կրկին նկատի ունեցեք. `sayHi`-ից հետո չկան փակագծեր: Եթե լինեին, ապա `func = sayHi()` կվերագրեր `sayHi()`-ի *կանչվելու արդյունքը* `func`-ին, այլ ոչ թե հենց `sayHi` *ֆունկցիան*:
3. Այժմ երկու եղանակով էլ ֆունկցիան կարող է կանչվել՝ `sayHi()` և `func()`:

Մենք `sayHi` հայտարարելու համար կարող էինք նաև օգտագործել Ֆունկցիայի Արտահայտություն՝ առաջին տողում.

```js
let sayHi = function() { // (1) ստեղծել
  alert( "Ողջույն" );
};

let func = sayHi;
// ...
```

Ամեն ինչ նույն կերպ կաշխատի:


````smart header="Ինչո՞ւ է վերջում կետ-ստորակետ:"
Կարող եք զարմանալ, թե ինչու Ֆունկցիայի Արտահայտությունը վերջում ունի կետ-ստորակետ `;`, բայց Ֆունկցիայի Հայտարարությունը չունի.

```js
function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
}*!*;*/!*
```

Պատասխանը պարզ է. Ֆունկցիայի Արտահայտությունը ստեղծվել է այստեղ որպես `function(…) {…}` վերագրման հայտարարության ներսում. `let sayHi = …;` (statement): Կետ-ստորակետը `;` խորհուրդ է տրվում հայտարարության վերջում, դա ֆունկցիայի շարահյուսության մաս չէ:

Կետ-ստորակետը կարող է լինել ավելի պարզ վերագրման դեպքում, ինչպիսին է `let sayHi = 5;`, այն առկա է նաև ֆունկցիա վերագրելու դեպքում:
````

## Հետկանչ ֆունկցիաներ

Դիտարկենք ֆունկցիաները որպես արժեքներ փոխանցելու և ֆունկցիաների արտահայտություններ օգտագործելու ավելի շատ օրինակներ:

Մենք կգրենք ֆունկցիա `ask(question, yes, no)` երեք պարամետրով:

`question`
: Հարցի տեքստը

`yes`
: Գործարկման համար ֆունկցիա, եթե պատասխանը «Դրական» է

`no`
: Գործարկման համար ֆունկցիա, եթե պատասխանը «Բացասական» է

Ֆունկցիան պետք է հարցնի `question` և, կախված օգտատիրոջ պատասխանից, կանչի `yes()` կամ `no()`.

```js run
*!*
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
*/!*

function showOk() {
  alert( "Դուք համաձայնեցիք:" );
}

function showCancel() {
  alert( "Դուք չեղարկեցիք գործարկումը։" );
}

// օգտագործումը. showOk և showCancel ֆունկցիաները փոխանցվում են ask ֆունկցիային որպես արգումենտներ
ask("Դուք համաձա՞յն եք:", showOk, showCancel);
```

Գործնականում նման ֆունկցիաները բավականին օգտակար են: Հիմնական տարբերությունը «իրական կյանքով» `ask`-ի և վերոնշյալ օրինակի միջև այն է, որ «իրական կյանքով» ֆունկցիաները օգտագործում են ավելի բարդ ուղիներ օգտատիրոջ հետ փոխազդելու համար, քան պարզ `confirm`-ը: Բրաուզերում նման ֆունկցիաները սովորաբար նկարում են գեղեցիկ տեսք ունեցող հարցերի պատուհան: Բայց դա այլ պատմություն է:

**`ask` ֆունկցիայի `showOk` և `showCancel` արգումենտները կոչվում են *callback functions* (հետկանչ ֆունկցիաներ) կամ պարզապես *callbacks* (հետկանչեր):**

Գաղափարն այն է, որ մենք փոխանցում ենք ֆունկցիա և ակնկալում, որ այն հետագայում «հետ կկանչվի» անհրաժեշտության դեպքում: Մեր պարագայում `showOk`-ը դառնում է հետկանչ «դրական» պատասխանի համար, իսկ `showCancel`-ը՝ «բացասական» պատասխանի համար:

Մենք կարող ենք օգտագործել Ֆունկցիայի Արտահայտություն՝ նույն ֆունկցիան շատ ավելի հակիրճ գրելու համար.

```js run no-beautify
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

*!*
ask(
  "Դուք համաձա՞յն եք:",
  function() { alert("Դուք համաձայնեցիք:"); },
  function() { alert("Դուք չեղարկեցիք գործարկումը։"); }
);
*/!*
```

Այստեղ ֆունկցիաները ճշգրիտ են հայտարարված `ask(...)` կանչի ներսում: Նրանք չունեն անվանում, ուստի կոչվում են *anonymous* (անանուն): Նման ֆունկցիաները հասանելի չեն `ask`-ից դուրս (քանի որ դրանք վերագրված չեն փոփոխականներին), բայց դա հենց այն է, ինչ մենք ուզում ենք այստեղ:

Շատ բնական է, որ նմանատիպ կոդ է հայտնվում մեր սքրիփթներում, այն JavaScript-ի ոգով է:

```smart header="Ֆունկցիան արժեք է, որը ներկայացնում է «գործողություն»"
Սովորական արժեքները, ինչպիսիք են տողերը կամ թվերը, ներկայացնում են *տվյալներ*:

Ֆունկցիան կարող է ընկալվել որպես *գործողություն*։

Մենք կարող ենք այն փոխանցել փոփոխականների միջև և գործարկել, երբ կցանկանանք:
```


## Function Expression vs Function Declaration

Եկեք ձևակերպենք Ֆունկցիայի Հայտարարության և Արտահայտության միջև հիմնական տարբերությունները:

Առաջին հերթին՝ շարահյությությունը. ինչպես տարանջատել դրանք կոդում:

- *Function Declaration* - ֆունկցիա՝ հայտարարված որպես առանձին հայտարարություն (statement), հիմնական կոդի հոսքում:

    ```js
    // Ֆունկցիայի Հայտարարություն
    function sum(a, b) {
      return a + b;
    }
    ```
- *Function Expression* - ֆունկցիա՝ ստեղծված արտահայտության ներսում կամ մեկ այլ շարահյուսական կառուցվածքի ներսում: Այստեղ ֆունկցիան ստեղծվում է «վերագրման արտահայտության» `=` աջ կողմում.

    ```js
    // Ֆունկցիայի Արտահայտություն
    let sum = function(a, b) {
      return a + b;
    };
    ```

Ավելի նուրբ տարբերությունն այն է, թե *երբ* է ֆունկցիան ստեղծվում JavaScript շարժիչի կողմից:

**Ֆունկցիայի Արտահայտությունը ստեղծվում է, երբ կատարումը հասնում է դրան և կարող է օգտագործվել միայն այդ պահից:**

Երբ կատարման հոսքն անցնում է վերագրման աջ կողմ `let sum = function…`, այդ պահից սկսած ֆունկցիան համարվում է ստեղծված և կարող է օգտագործվել (վերագրվել, կանչվել, և այլն․․․):

Ֆունկցիայի Հայտարարությունները տարբեր են:

**Ֆունկցիայի Հայտարարությունը կարող է կանչվել ավելի վաղ, քան այն սահմանվել է:**

Օրինակ՝ գլոբալ Ֆունկցիայի Հայտարարությունը հասանելի է ամբողջ սքրիփթում, անկախ նրանից, թե որտեղ է այն գտնվում:

Դա պայմանավորված է ներքին ալգորիթմներով: Երբ JavaScript-ը պատրաստվում է գործարկել սքրիփթը, այն նախ որոնում է գլոբալ Ֆունկցիայի Հայտարարությունները և ստեղծում ֆունկցիաները: Մենք կարող ենք դա համարել որպես «նախաձեռնման փուլ»:

ԵՎ այն բանից հետո, երբ բոլոր Ֆունկցիայի Հայտարարությունները մշակվել են, կոդը կատարվում է: Այսպիսով, այն ունի հասանելիություն այս ֆունկցիաներին:

Օրինակ՝ սա աշխատում է.

```js run refresh untrusted
*!*
sayHi("Պողոս"); // Ողջույն Պողոս
*/!*

function sayHi(name) {
  alert( `Ողջույն ${name}` );
}
```

Ֆունկցիայի հայտարարությունը `sayHi` ստեղծվում է, երբ JavaScript-ը պատրաստվում է սկսել սքրիփթը և դրա մեջ ամենուր տեսանելի է:

...Եթե դա լիներ Ֆունկցիայի Արտահայտություն, ապա այն չէր աշխատի.

```js run refresh untrusted
*!*
sayHi("Պողոս"); // սխալ
*/!*

let sayHi = function(name) {  // (*) այլևս ոչ մի կախարդանք
  alert( `Ողջույն ${name}` );
};
```

Ֆունկցիայի Արտահայտությունները ստեղծվում են, երբ կատարումը հասնում է դրանց: Դա տեղի կունենա միայն `(*)` տողում՝ չափազանց ուշ։

Ֆունկցիայի Արտահայտությունների մեկ այլ առանձնահատկություն է նրանց բլոկային տեսադաշտը։

**Խիստ ռեժիմում, երբ Ֆունկցիայի Հայտարարությունը գտնվում է կոդի բլոկի ներսում, այն տեսանելի է ամենուր՝ այդ բլոկի ներսում, բայց՝ ոչ դրանից դուրս:**

Օրինակ՝ եկեք պատկերացնենք, որ մենք պետք է հայտարարենք `welcome()` ֆունկցիան՝ կախված `age` փոփոխականից, որը մենք ստանում ենք գործարկման ընթացքում: Եվ հետո մենք նախատեսում ենք օգտագործել այն որոշ ժամանակ անց:

Եթե մենք օգտագործում ենք Ֆունկցիայի Հայտարարություն, այն չի աշխատի այնպես, ինչպես նախատեսված էր.

```js run
let age = prompt("Քանի՞ տարեկան եք:", 18);

// conditionally declare a function
if (age < 18) {

  function welcome() {
    alert("Ողջույն");
  }

} else {

  function welcome() {
    alert("Ողջույններ");
  }

}

// ...օգտագործել ավելի ուշ
*!*
welcome(); // սխալ` welcome is not defined
*/!*
```

Դա պայմանավորված է նրանով, որ Ֆունկցիայի Հայտարարությունը տեսանելի է միայն կոդի բլոկի ներսում, որտեղ այն գտնվում է:

Ահա ևս մեկ օրինակ.

```js run
let age = 16; // օրինակի համար վերցրեք 16

if (age < 18) {
*!*
  welcome();                // \   (գործարկվում է)
*/!*
                            //  |
  function welcome() {      //  |
    alert("Ողջույն");       //  |  Ֆունկցիայի Հայտարարությունը հասանելի է
  }                         //  |  ամենուր՝ բլոկում, որտեղ այն հայտարարված է
                            //  |
*!*
  welcome();                // /   (գործարկվում է)
*/!*

} else {

  function welcome() {    
    alert("Ողջույններ");
  }
}

// Այստեղ մենք ձևավոր փակագծերից դուրս ենք,
// այնպես որ մենք չենք կարող տեսնել դրանց ներսում ստեղծված Ֆունկցիայի Հայտարարությունները:

*!*
welcome(); // սխալ՝ welcome is not defined
*/!*
```

Ի՞նչ կարող ենք անել, որպեսզի `welcome`-ը դարձնենք տեսանելի `if`-ից դուրս:

Ճիշտ մոտեցումը կլինի՝ օգտագործել Ֆունկցիայի Արտահայտություն և վերագրել `welcome`-ը փոփոխականին, որը հայտարարված է `if`-ից դուրս և ունի համապատասխան տեսանելիություն:

Այս կոդը աշխատում է այնպես, ինչպես նախատեսված է.

```js run
let age = prompt("Քանի՞ տարեկան եք:", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("Ողջույն");
  };

} else {

  welcome = function() {
    alert("Ողջույններ");
  };

}

*!*
welcome(); // այժմ նորմալ է
*/!*
```

Կամ մենք կարող ենք այն էլ ավելի պարզեցնել՝ օգտագործելով `?` հարցական նշանի օպերատոր.

```js run
let age = prompt("Քանի՞ տարեկան եք:", 18);

let welcome = (age < 18) ?
  function() { alert("Ողջույն"); } :
  function() { alert("Ողջույններ"); };

*!*
welcome(); // այժմ նորմալ է
*/!*
```


```smart header="Ե՞րբ օգտագործել Ֆունկցիայի Հայտարարություն, երբ՝ Ֆունկցիայի Արտահայտություն:"
Որպես հիմնական կանոն, երբ մենք պետք է հայտարարենք ֆունկցիա, առաջին հերթին պետք է հաշվի առնել Ֆունկցիայի Հայտարարության շարահուսությունը: Այն ավելի շատ ազատություն է տալիս մեր կոդի դասավորության հարցում, քանի որ մենք կարող ենք կանչել այդպիսի ֆունկցիաները նախքան նրանց հայտարարումը:

Դա նաև ավելի լավ է ընթեռնելիության համար, քանի որ կոդում ավելի հեշտ է փնտրել `function f(…) {…}`, քան՝ `let f = function(…) {…};`: Ֆունկցիայի Հայտարարություններն ավելի «աչք են գրավում»:

...Բայց եթե Ֆունկցիայի Հայտարարությունն ինչ-ինչ պատճառներով մեզ չի համապատասխանում, կամ մեզ անհրաժեշտ է պայմանական հայտարարագիր (մենք հենց նոր տեսանք օրինակը), ապա պետք է օգտագործվի Ֆունկցիայի Արտահայտություն:
```

## Ամփոփում

- Ֆունկցիաներն արժեքներ են: Դրանք կարող են նշանակվել, պատճենվել կամ հայտարարվել կոդի ցանկացած վայրում:
- Եթե հիմնական կոդի հոսքում ֆունկցիան հայտարարագրվում է որպես առանձին հայտարարություն, դա կոչվում է «Ֆունկցիայի Հայտարարություն» (Function Declaration):
- Եթե ֆունկցիան ստեղծվում է որպես արտահայտության մաս, այն կոչվում է «Ֆունկցիայի Արտահայտություն» (Function Expression):
- Ֆունկցիայի Հայտարարությունները մշակվում են նախքան կոդի բլոկի գործարկումը: Դրանք տեսանելի են բլոկում ամենուր:
- Ֆունկցիայի Արտահայտությունները ստեղծվում են, երբ կատարողական հոսքը հասնում է նրանց:

Շատ դեպքերում, երբ մենք պետք է հայտարարագրենք ֆունկցիա, գերադասելի է Ֆունկցիայի Հայտարարությունը, քանի որ այն տեսանելի է նախքան հայտարարագրումը: Դա մեզ ավելի շատ ճկունություն է տալիս կոդի կազմակերպման մեջ և սովորաբար ավելի ընթեռնելի է:

Այսպիսով, մենք պետք է օգտագործենք Ֆունկցիայի Արտահայտություն միայն այն դեպքում, երբ Ֆունկցիայի Հայտարարությունը հարմար չէ առաջադրանքի համար: Մենք տեսել ենք դրա մի քանի օրինակ այս գլխում և ավելին կտեսնենք հետագայում:
