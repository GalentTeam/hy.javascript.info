# Function Expression

Ֆունկցիան JavaScript-ում «լեզվի կախարդական կառուցվածք» չէ, բայց արժեքի հատուկ տեսակ է:

Այն շարահյուսությունը, որ մինչ այս օգտագործել ենք, կոչվում է *Function Declaration* (Ֆունկցիայի Հայտարարություն):

```js
function sayHi() {
  alert( "Ողջույն" );
}
```

Կա նաև այլ շարահյուսություն, որը կոչվում է *Function Expression* (Ֆունկցիայի Արտահայտություն):

Դա մեզ թույլ է տալիս ստեղծել նոր ֆունկցիա ցանկացած արտահայտության մեջտեղում:

Օրինակ.

```js
let sayHi = function() {
  alert( "Ողջույն" );
};
```

Այստեղ մենք կարող ենք տեսնել, որ `sayHi` փոփոխականը ստանում է արժեք՝ նոր ֆունկցիա, որը ստեղծվել է այսպես՝ `function() { alert("Ողջույն"); }`:

Քանի որ ֆունկցիայի ստեղծումը տեղի է ունենում վերագրման արտահայտության համատեքստում (`=` նշանի աջ կողմում), ապա սա *Function Expression* է:

Նկատի ունեցեք, որ `function` հիմնաբառից հետո չկա անվանում: Անվան բացթողումը թույլատրելի է Ֆունկցիայի Արտահայտությունների համար:

Այստեղ մենք անմիջապես վերագրում ենք այն փոփոխականին, ուստի այս կոդի նմուշների իմաստը նույնն է. «ստեղծել ֆունկցիա և տեղադրել այն `sayHi` փոփոխականում»:

Ավելի առաջադեմ իրավիճակներում, որոնց մենք հետո կհանդիպենք, ֆունկցիան կարող է ստեղծվել և անմիջապես կանչվել կամ պլանավորվել ավելի ուշ գործարկման համար, ոչ մի տեղ չպահվել, այդպիսով մնալով անանուն:

## Ֆունկցիան արժեք է

Եկեք կրկնենք. անկախ նրանից, թե ինչպես է ստեղծվում ֆունկցիան, այն արժեք է: Վերոնշյալ երկու օրինակներն էլ պահում են ֆունկցիան `sayHi` փոփոխականում:

Մենք կարող ենք նույնիսկ տպել այդ արժեքը՝ օգտագործելով `alert`.

```js run
function sayHi() {
  alert( "Ողջույն" );
}

*!*
alert( sayHi ); // ցուցադրում է ֆունկցիայի կոդը
*/!*
```

Նկատի ունեցեք, որ վերջին տողը չի գործարկում ֆունկցիան, որովհետև `sayHi`-ից հետո չկան փակագծեր: Կան ծրագրավորման լեզուներ, որտեղ ֆունկցիայի անվան ցանկացած հիշատակում հանգեցնում է դրա գործարկմանը, բայց JavaScript-ը այդպիսին չէ։

JavaScript-ում ֆունկցիան արժեք է, այնպես որ մենք կարող ենք դրան վերաբերվել որպես արժեքի: Վերոնշյալ կոդը ցույց է տալիս իր տողային ներկայացումը, որը սկզբնական կոդը է:

Անշուշտ, ֆունկցիան հատուկ արժեք է, այն իմաստով, որ մենք կարող ենք այն կանչել որպես `sayHi()`:

Բայց դա դեռևս արժեք է: Այսպիսով, մենք կարող ենք աշխատել դրա հետ, ինչպես այլ տեսակի արժեքների հետ:

Մենք կարող ենք պատճենել ֆունկցիան մեկ այլ փոփոխականում.

```js run no-beautify
function sayHi() {     // (1) ստեղծել
  alert( "Ողջույն" );
}

let func = sayHi;      // (2) պատճենել

func(); // Ողջույն     // (3) գործարկել կրկնօրինակը (սա աշխատում է)
sayHi(); // Ողջույն    //     սա նույնպես դեռ աշխատում է (ինչու ոչ)
```

Ահա մանրամասն, թե ինչ է տեղի ունենում վերևում.

1. Ֆունկցիայի Հայտարարությունը `(1)` ստեղծում է ֆունկցիա և տեղադրում այն `sayHi` փոփոխականում:
2. Տող `(2)`-ը պատճենում է այն `func` փոփոխականում: Կրկին նկատի ունեցեք. `sayHi`-ից հետո չկան փակագծեր: Եթե լինեին, ապա `func = sayHi()` կվերագրեր `sayHi()`-ի *կանչվելու արդյունքը* `func`-ին, այլ ոչ թե հենց `sayHi` *ֆունկցիան*:
3. Այժմ երկու եղանակով էլ ֆունկցիան կարող է կանչվել՝ `sayHi()` և `func()`:

Մենք `sayHi` հայտարարելու համար կարող էինք նաև օգտագործել Ֆունկցիայի Արտահայտություն՝ առաջին տողում.

```js
let sayHi = function() { // (1) ստեղծել
  alert( "Ողջույն" );
};

let func = sayHi;
// ...
```

Ամեն ինչ նույն կերպ կաշխատի:


````smart header="Ինչո՞ւ է վերջում կետ-ստորակետ:"
Կարող եք զարմանալ, թե ինչու Ֆունկցիայի Արտահայտությունը վերջում ունի կետ-ստորակետ `;`, բայց Ֆունկցիայի Հայտարարությունը չունի.

```js
function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
}*!*;*/!*
```

Պատասխանը պարզ է. Ֆունկցիայի Արտահայտությունը ստեղծվել է այստեղ որպես `function(…) {…}` վերագրման հայտարարության ներսում. `let sayHi = …;` (statement): Կետ-ստորակետը `;` խորհուրդ է տրվում հայտարարության վերջում, դա ֆունկցիայի շարահյուսության մաս չէ:

Կետ-ստորակետը կարող է լինել ավելի պարզ վերագրման դեպքում, ինչպիսին է `let sayHi = 5;`, այն առկա է նաև ֆունկցիա վերագրելու դեպքում:
````

## Հետկանչ ֆունկցիաներ

Դիտարկենք ֆունկցիաները որպես արժեքներ փոխանցելու և ֆունկցիաների արտահայտություններ օգտագործելու ավելի շատ օրինակներ:

Մենք կգրենք ֆունկցիա `ask(question, yes, no)` երեք պարամետրով:

`question`
: Հարցի տեքստը

`yes`
: Գործարկման համար ֆունկցիա, եթե պատասխանը «Դրական» է

`no`
: Գործարկման համար ֆունկցիա, եթե պատասխանը «Բացասական» է

Ֆունկցիան պետք է հարցնի `question` և, կախված օգտատիրոջ պատասխանից, կանչի `yes()` կամ `no()`.

```js run
*!*
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
*/!*

function showOk() {
  alert( "Դուք համաձայնեցիք:" );
}

function showCancel() {
  alert( "Դուք չեղարկեցիք գործարկումը։" );
}

// օգտագործումը. showOk և showCancel ֆունկցիաները փոխանցվում են ask ֆունկցիային որպես արգումենտներ
ask("Դուք համաձա՞յն եք:", showOk, showCancel);
```

Գործնականում նման ֆունկցիաները բավականին օգտակար են: Հիմնական տարբերությունը «իրական կյանքով» `ask`-ի և վերոնշյալ օրինակի միջև այն է, որ «իրական կյանքով» ֆունկցիաները օգտագործում են ավելի բարդ ուղիներ օգտատիրոջ հետ փոխազդելու համար, քան պարզ `confirm`-ը: Բրաուզերում նման ֆունկցիաները սովորաբար նկարում են գեղեցիկ տեսք ունեցող հարցերի պատուհան: Բայց դա այլ պատմություն է:

**`ask` ֆունկցիայի `showOk` և `showCancel` արգումենտները կոչվում են *callback functions* (հետկանչ ֆունկցիաներ) կամ պարզապես *callbacks* (հետկանչեր):**

Գաղափարն այն է, որ մենք փոխանցում ենք ֆունկցիա և ակնկալում, որ այն հետագայում «հետ կկանչվի» անհրաժեշտության դեպքում: Մեր պարագայում `showOk`-ը դառնում է հետկանչ «դրական» պատասխանի համար, իսկ `showCancel`-ը՝ «բացասական» պատասխանի համար:

Մենք կարող ենք օգտագործել Ֆունկցիայի Արտահայտություն՝ նույն ֆունկցիան շատ ավելի հակիրճ գրելու համար.

```js run no-beautify
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

*!*
ask(
  "Դուք համաձա՞յն եք:",
  function() { alert("Դուք համաձայնեցիք:"); },
  function() { alert("Դուք չեղարկեցիք գործարկումը։"); }
);
*/!*
```

Այստեղ ֆունկցիաները ճշգրիտ են հայտարարված `ask(...)` կանչի ներսում: Նրանք չունեն անվանում, ուստի կոչվում են *anonymous* (անանուն): Նման ֆունկցիաները հասանելի չեն `ask`-ից դուրս (քանի որ դրանք վերագրված չեն փոփոխականներին), բայց դա հենց այն է, ինչ մենք ուզում ենք այստեղ:

Շատ բնական է, որ նմանատիպ կոդ է հայտնվում մեր սքրիփթներում, այն JavaScript-ի ոգով է:

```smart header="Ֆունկցիան արժեք է, որը ներկայացնում է «գործողություն»"
Սովորական արժեքները, ինչպիսիք են տողերը կամ թվերը, ներկայացնում են *տվյալներ*:

Ֆունկցիան կարող է ընկալվել որպես *գործողություն*։

Մենք կարող ենք այն փոխանցել փոփոխականների միջև և գործարկել, երբ կցանկանանք:
```


## Function Expression vs Function Declaration

Եկեք ձևակերպենք Ֆունկցիայի Հայտարարության և Արտահայտության միջև հիմնական տարբերությունները:

Առաջին հերթին՝ շարահյությությունը. ինչպես տարանջատել դրանք կոդում:

- *Function Declaration* - ֆունկցիա՝ հայտարարված որպես առանձին հայտարարություն (statement), հիմնական կոդի հոսքում:

    ```js
    // Ֆունկցիայի Հայտարարություն
    function sum(a, b) {
      return a + b;
    }
    ```
- *Function Expression* - ֆունկցիա՝ ստեղծված արտահայտության ներսում կամ մեկ այլ շարահյուսական կառուցվածքի ներսում: Այստեղ ֆունկցիան ստեղծվում է «վերագրման արտահայտության» `=` աջ կողմում.

    ```js
    // Ֆունկցիայի Արտահայտություն
    let sum = function(a, b) {
      return a + b;
    };
    ```

Ավելի նուրբ տարբերությունն այն է, թե *երբ* է ֆունկցիան ստեղծվում JavaScript շարժիչի կողմից:

**Ֆունկցիայի Արտահայտությունը ստեղծվում է, երբ կատարումը հասնում է դրան և կարող է օգտագործվել միայն այդ պահից:**

Երբ կատարման հոսքն անցնում է վերագրման աջ կողմ `let sum = function…`, այդ պահից սկսած ֆունկցիան համարվում է ստեղծված և կարող է օգտագործվել (վերագրվել, կանչվել, և այլն․․․):

Ֆունկցիայի Հայտարարությունները տարբեր են:

**Ֆունկցիայի Հայտարարությունը կարող է կանչվել ավելի վաղ, քան այն սահմանվել է:**

Օրինակ՝ գլոբալ Ֆունկցիայի Հայտարարությունը հասանելի է ամբողջ սքրիփթում, անկախ նրանից, թե որտեղ է այն գտնվում:

Դա պայմանավորված է ներքին ալգորիթմներով: Երբ JavaScript-ը պատրաստվում է գործարկել սքրիփթը, այն նախ որոնում է գլոբալ Ֆունկցիայի Հայտարարությունները և ստեղծում ֆունկցիաները: Մենք կարող ենք դա համարել որպես «նախաձեռնման փուլ»:

ԵՎ այն բանից հետո, երբ բոլոր Ֆունկցիայի Հայտարարությունները մշակվել են, կոդը կատարվում է: Այսպիսով, այն ունի հասանելիություն այս ֆունկցիաներին:

Օրինակ՝ սա աշխատում է.

```js run refresh untrusted
*!*
sayHi("Պողոս"); // Ողջույն Պողոս
*/!*

function sayHi(name) {
  alert( `Ողջույն ${name}` );
}
```

Ֆունկցիայի հայտարարությունը `sayHi` ստեղծվում է, երբ JavaScript-ը պատրաստվում է սկսել սքրիփթը և դրա մեջ ամենուր տեսանելի է:

...Եթե դա լիներ Ֆունկցիայի Արտահայտություն, ապա այն չէր աշխատի.

```js run refresh untrusted
*!*
sayHi("Պողոս"); // սխալ
*/!*

let sayHi = function(name) {  // (*) այլևս ոչ մի կախարդանք
  alert( `Ողջույն ${name}` );
};
```

Ֆունկցիայի Արտահայտությունները ստեղծվում են, երբ կատարումը հասնում է դրանց: Դա տեղի կունենա միայն `(*)` տողում՝ չափազանց ուշ։

Ֆունկցիայի Արտահայտությունների մեկ այլ առանձնահատկություն է նրանց բլոկային տեսադաշտը։

**Խիստ ռեժիմում, երբ Ֆունկցիայի Հայտարարությունը գտնվում է կոդի բլոկի ներսում, այն տեսանելի է ամենուր՝ այդ բլոկի ներսում, բայց՝ ոչ դրանից դուրս:**

Օրինակ՝ եկեք պատկերացնենք, որ մենք պետք է հայտարարենք `welcome()` ֆունկցիան՝ կախված `age` փոփոխականից, որը մենք ստանում ենք գործարկման ընթացքում: Եվ հետո մենք նախատեսում ենք օգտագործել այն որոշ ժամանակ անց:

Եթե մենք օգտագործում ենք Ֆունկցիայի Հայտարարություն, այն չի աշխատի այնպես, ինչպես նախատեսված էր.

```js run
let age = prompt("Քանի՞ տարեկան եք:", 18);

// conditionally declare a function
if (age < 18) {

  function welcome() {
    alert("Ողջույն");
  }

} else {

  function welcome() {
    alert("Ողջույններ");
  }

}

// ...օգտագործել ավելի ուշ
*!*
welcome(); // սխալ` welcome is not defined
*/!*
```

Դա պայմանավորված է նրանով, որ Ֆունկցիայի Հայտարարությունը տեսանելի է միայն կոդի բլոկի ներսում, որտեղ այն գտնվում է:

Ահա ևս մեկ օրինակ.

```js run
let age = 16; // օրինակի համար վերցրեք 16

if (age < 18) {
*!*
  welcome();                // \   (գործարկվում է)
*/!*
                            //  |
  function welcome() {      //  |
    alert("Ողջույն");       //  |  Ֆունկցիայի Հայտարարությունը հասանելի է
  }                         //  |  ամենուր՝ բլոկում, որտեղ այն հայտարարված է
                            //  |
*!*
  welcome();                // /   (գործարկվում է)
*/!*

} else {

  function welcome() {    
    alert("Ողջույններ");
  }
}

// Այստեղ մենք ձևավոր փակագծերից դուրս ենք,
// այնպես որ մենք չենք կարող տեսնել դրանց ներսում ստեղծված Ֆունկցիայի Հայտարարությունները:

*!*
welcome(); // սխալ՝ welcome is not defined
*/!*
```

Ի՞նչ կարող ենք անել, որպեսզի `welcome`-ը դարձնենք տեսանելի `if`-ից դուրս:

Ճիշտ մոտեցումը կլինի՝ օգտագործել Ֆունկցիայի Արտահայտություն և վերագրել `welcome`-ը փոփոխականին, որը հայտարարված է `if`-ից դուրս և ունի համապատասխան տեսանելիություն:

Այս կոդը աշխատում է այնպես, ինչպես նախատեսված է.

```js run
let age = prompt("Քանի՞ տարեկան եք:", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("Ողջույն");
  };

} else {

  welcome = function() {
    alert("Ողջույններ");
  };

}

*!*
welcome(); // այժմ նորմալ է
*/!*
```

Կամ մենք կարող ենք այն էլ ավելի պարզեցնել՝ օգտագործելով `?` հարցական նշանի օպերատոր.

```js run
let age = prompt("Քանի՞ տարեկան եք:", 18);

let welcome = (age < 18) ?
  function() { alert("Ողջույն"); } :
  function() { alert("Ողջույններ"); };

*!*
welcome(); // այժմ նորմալ է
*/!*
```


```smart header="When to choose Function Declaration versus Function Expression?"
As a rule of thumb, when we need to declare a function, the first to consider is Function Declaration syntax. It gives more freedom in how to organize our code, because we can call such functions before they are declared.

That's also better for readability, as it's easier to look up `function f(…) {…}` in the code than `let f = function(…) {…};`. Function Declarations are more "eye-catching".

...But if a Function Declaration does not suit us for some reason, or we need a conditional declaration (we've just seen an example), then Function Expression should be used.
```

## Summary

- Functions are values. They can be assigned, copied or declared in any place of the code.
- If the function is declared as a separate statement in the main code flow, that's called a "Function Declaration".
- If the function is created as a part of an expression, it's called a "Function Expression".
- Function Declarations are processed before the code block is executed. They are visible everywhere in the block.
- Function Expressions are created when the execution flow reaches them.

In most cases when we need to declare a function, a Function Declaration is preferable, because it is visible prior to the declaration itself. That gives us more flexibility in code organization, and is usually more readable.

So we should use a Function Expression only when a Function Declaration is not fit for the task. We've seen a couple of examples of that in this chapter, and will see more in the future.
